Classes = [
   {
      "name" : "Config",
      "functions": [
   {"name":"global","code":"git config --global user.name \"John Doe\"\n=> username change to \"John Doe\"\ngit config --global user.email \"johndoe@example.com\"\n=> email change to \"johndoe@example.com\"","signature":"git config --global options","description":"The ﬁrst thing you should do when you install Git is to set your <b>user name</b> and <b>e-mail address</b>. This is important because every Git commit uses this information, and it’s immutably baked into the commits you pass around."},
   {"name":"list","code":"git config --list\n=> user.name=Scott Chacon\n   user.email=schacon@gmail.com\n   color.status=auto\n   color.branch=auto\n   color.interactive=auto\n   color.diff=auto\n   ...","signature":"git config --list","description":"If you want to check your settings, you can use the <tt>git config --list</tt> command to list all the settings Git can ﬁnd at that point:"},
      ]
   },
   {
      "name" : "Basic",
      "functions": [
   {"name":"init","code":"git init\n=> create an empty Git repository\ngit add *.c\n=> add all files *.c to the index\ngit add README\n=> add file README to the index\ngit commit m ’initial project version’\n=> first index","signature":"git init","description":"Create an empty Git repository or reinitialize an existing one. This creates a new subdirectory named .git that contains all of your necessary repository ﬁles - a Git repository skeleton."},
   {"name":"clone","code":"git clone git://github.com/schacon/grit.git\n=> That creates a directory named “grit”\n   - initializes a .git directory inside it,\n   - pulls down all the data for that repository,\n   - checks out a working copy of the latest ver-sion.\n   If you go into the new grit directory, you’ll see the project ﬁles\n   in there, ready to be worked on or used.","signature":"git clone url","description":"Clones <tt>a repository</tt> into a newly created directory from <b>url</b>, creates <tt>remote-tracking branches</tt> for each branch in the cloned repository, and creates and checks out <tt>an initial branch</tt> that is forked from the cloned repository’s currently active branch."}
   
      ]
   },
   {
      "name" : "Recording Changes",
      "functions": [
{"name":"status","code":"git status\n=> # On branch master\n   nothing to commit (working directory clean)\nvim README\ngit status\n=> # On branch master\n   # Untracked files:\n   # (use \"git add <file>...\" to include in what will be committed)\n   #\n   # README","signature":"git status","description":"The main tool you use to determine which ﬁles are in which state is the <tt>git status</tt> command."},
{"name":"log","code":"git log\n=> commit ca82a6dff817ec66f44342007202690a93763949\n   Author: Scott Chacon <schacon@gee-mail.com>\n   Date: Mon Mar 17 21:52:11 2008 -0700\n \n       changed the version number\n\n   commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n   Author: Scott Chacon <schacon@gee-mail.com>\n   Date: Sat Mar 15 16:40:33 2008 -0700\n\n       removed unnecessary test code\n\n    commit a11bef06a3f659402fe7563abf99ad00de2209e6\n    Author: Scott Chacon <schacon@gee-mail.com>\n    Date: Sat Mar 15 10:31:28 2008 -0700\n\n       first commit","signature":"git log","description":"Show commit logs. After you have created several commits, or if you have <tt>cloned a repository</tt> with an existing commit history, you’ll probably want to <tt>look back</tt> to see what has happened. The most basic and powerful tool to do this is the <tt>git log</tt> command."},
{"name":"add","code":"git add README\ngit status\n=> # On branch master\n   # Changes to be committed:\n   # (use \"git reset HEAD <file>...\" to unstage)\n   #\n   # new file: README","signature":"git add path","description":"In order to begin <tt>tracking</tt> a new ﬁle, you use the command <tt>git add</tt>. <b>Path</b> is files to add content from <tt>fileglobs</tt> (*.c) can be given to add all matching files and also a <tt>leading directory name</tt> (e.g. dir to add dir/file1 and dir/file2) can be given to add all files in the directory, recursively."} ,
{"name":"change","code":"vim README # edit README file\ngit status\n=> # On branch master\n   # Changes to be committed:\n   # (use \"git reset HEAD <file>...\" to unstage)\n   # new file: README\n   # Changed but not updated:\n   # (use \"git add <file>...\" to update what will be committed)\n   # modified: benchmarks.rb\ngit add benchmarks.rb\ngit status\n=> # On branch master\n   # Changes to be committed:\n   # (use \"git reset HEAD <file>...\" to unstage)\n   # new file: README\n   # modified: benchmarks.rb","signature":"change your tracked files","description":"Let’s change a ﬁle that was already <tt>tracked</tt>. If you <b>change</b> a previously <tt>tracked ﬁle</tt> called <tt>benchmarks.rb</tt> and then run your status command again, you get somethingthat looks like below example."} ,
{"name":"rm","code":"git rm grit.gemspec\n=> rm 'grit.gemspec'\n $ git status\n On branch master\n    Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n       deleted: grit.gemspec\ngit rm `git status | grep deleted | awk '{print $2}'`\n=> rm 'test1.txt'\n   rm 'test2.txt'\n   rm 'test3.txt'","signature":"git rm file","description":"Remove <b>files</b> from the index, or from the working tree and the index. <tt>git rm</tt> will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use /bin/rm if you want to do that.) The <b>files</b> being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the -f option."},
{"name":"mv","code":"git mv README README.txt\ngit status\n=> On branch master\n   Changes to be committed:\n     (use \"git reset HEAD <file>...\" to unstage)\n   \n           renamed:    README -> README.txt","signature":"git mv source destination","description":"Move or rename a file, a directory, or a symlink. Unlike many other VCS systems, Git doesn’t explicitly track file movement. If you <tt>rename</tt> a file in Git, no metadata is stored in Git that tells it you renamed the file. However, Git is <tt>pretty smart</tt> about figuring that out after the fact — we’ll deal with detecting file movement a bit later."} ,
{"name":"diff","code":"git diff\n=> diff --git a/benchmarks.rb b/benchmarks.rb\n index 3cb747f..da65585 100644\n --- a/benchmarks.rb\n +++ b/benchmarks.rb\n @@ -36,6 +36,10 @@ def main\n @commit.parents[0].parents[0].parents[0]\n end\n \n + run_code(x, 'commits 1') do\n + git.commits.size\n + end\n +\n run_code(x, 'commits 2') do\n log = git.commits('master', 15)\n log.size\ngit diff -cached\n=> Show differences between the index and the most recent commit.\ngit diff HEAD\n=> Show the differences between your working directory and the most recent commit.","signature":"git diff","description":"Show differences between your working directory and the index, view your <tt>staged</tt> and <tt>unstaged</tt> changes. You want to know exactly what you changed, not just which files were changed — you can use the <tt>git diff</tt> command."},
{"name":"commit","code":"git commit\n=> # Please enter the commit message for your changes.Lines starting\n   # with '#' will be ignored, and an empty message aborts the commit.\n   # On branch master\n   # Changes to be committed:\n   # new file: README\n   # modified: benchmarks.rb\n   ~\n   \".git/COMMIT_EDITMSG\" 10L, 283C\ngit commit -m \"Story 182: Fix benchmarks for speed\"\n=> [master 463dc4f] Story 182: Fix benchmarks for speed\n   2 files changed, 3 insertions(+)\n   create mode 100644 README\ngit commit -a -m 'added new benchmarks'\n=> [master 83e38c7] added new benchmarks\n   1 files changed, 5 insertions(+)","signature":"git commit [-a] [-m msg]","description":"Committing Your Changes. Your <tt>staging area</tt> is set up the way you want it, you can <b>commit</b> your changes. Remember that anything that is still <tt>unstaged</tt> — any files you have created or modified that you haven’t run <tt>git add</tt> on since you edited them — won’t go into this commit. You can type your commit <b>message</b> inline with the commit command by specifying it after a <b>-m</b> flag. Providing the <b>-a</b> option to the git commit command makes Git <tt>automatically stage</tt> every file that is already tracked before doing the <b>commit</b>."}, {"name":"amend","code":"git commit --amend\n=> [master 60950ec] initial commit\n   1 files changed, 1 insertions(+)","signature":"git commit --amend","description":"Combine the <tt>staged changes</tt> with the <tt>previous commit</tt> and replace the previous commit with the resulting snapshot. Running this when there is nothing staged lets you edit the previous commit’s message without altering its snapshot."},
{"name":"gitignore","code":"git status\n=> ...\n   # Untracked files:\n   #       Documentation/foo.html\n   #       Documentation/gitignore.html\n   #       file.o\n   #       lib.a\n   #       src/internal.o\ncat .git/info/exclude\n=> *.[oa]    # ignore objects and archives, anywhere in the tree.\ncat Documentation/.gitignore\n=> *.html    # ignore generated html files,\n   !foo.html # except foo.html which is maintained by hand\ngit status\n=> # Untracked files:\n   #       Documentation/foo.html","signature":".gitignore","description":"You’ll have a class of files that you <tt>don’t want</tt> Git to <tt>automatically</tt> add or even show you as being untracked. These are <tt>generally automatically generated</tt> files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named <b>.gitignore</b>."},
      ]
   },
   {
      "name" : "Undo",
      "functions": [
      {"name":"checkout","code":"git status\n=> On branch master\n   Changes not staged for commit:\n        modified:   hi.txt\ngit checkout master hi.txt\n=> On branch master\n   nothing to commit, working directory clean","signature":"git checkout <commit> <file>","description":"Check out a previous version of a file. This turns the <b>file</b> that resides in the working directory into an exact copy of the one from <b>commit</b> and adds it to the staging area."}
      ]
   },
   {
      "name" : "Branch",
      "functions": [
   {"name":"branch","code":"git branch\n=> master\ngit branch blue\ngit branch\n=>  blue\n  * master\ngit branch -d blue\ngit branch\n=> master","signature":"git branch","description":"List, create, or delete branches"},
   {"name":"checkout","code":"git branch\n=>* master\n    blue\ngit checkout blue\n=> Switched to branch 'blue'","signature":"git checkout <branch>","description":"Checkout a branch or paths to the working tree"},
   {"name":"merge","code":"git branch\n=> * master\n   removals\nls\n=> README hello.rb more.txt test.txt\ngit merge removals\n=> Updating 8bd6d8b..8f7c949\n   Fast-forward\n      more.txt | 1 -\n      test.txt | 1 -\n   2 files changed, 0 insertions(+), 2 deletions(-)\n      delete mode 100644 more.txt\n      delete mode 100644 test.txt\nls\n=> README hello.rb","signature":"git merge branch","description":"merge a branch context into your current one. Once you have work isolated in a <b>branch</b>, you will eventually want to <tt>incorporate</tt> it into your main branch. You can <tt>merge</tt> any <b>branch</b> into your current branch with the <tt>git merge</tt> command."},
   {"name":"rebase","code":"git checkout new-feature\ngit rebase master","signature":"git rebase branch","description":"Rebasing is a common way to <tt>integrate</tt> upstream changes into your local repository. Pulling in upstream changes with <tt>git merge</tt> results in a superfluous merge commit every time you want to see how the project has progressed. On the other hand, rebasing is like saying, “I want to <tt>base</tt> my changes on what everybody has already done.”"}
      ]
   },
   {
      "name" : "Remote",
      "functions": [
         {"name":"remote","code":"git remote\ngit remote add github git@github.com:schacon/hw.git\ngit remote -v\n=> github git@github.com:schacon/hw.git (fetch)\n   github git@github.com:schacon/hw.git (push)","signature":"git remote add remote url","description":"If you have not cloned an existing repository and want to connect your repository to a <b>remote url</b>, you need to add it with <tt>git remote add remote url</tt>. Now you are able to push your changes to the selected remote server"},
         {"name":"push","code":"git push github master\n=> Counting objects: 25, done.\n   Delta compression using up to 2 threads.\n   Compressing objects: 100% (25/25), done.\n   Writing objects: 100% (25/25), 2.43 KiB, done.\n   Total 25 (delta 4), reused 0 (delta 0)\n   To git@github.com:schacon/hw.git\n       * [new branch]      master -> master","signature":"git push remote branch","description":"Update remote refs along with associated objects. To <tt>share</tt> the cool commits you've done with others, you need to push your changes to the <tt>remote repository</tt>. To do this, you run <tt>git push remote branch</tt> which will attempt to make your <b>branch</b> the new <b>branch</b> on the <b>remote</b>."},
         {"name":"fetch","code":"git fetch github\n=> remote: Counting objects: 4006, done.\n   remote: Compressing objects: 100% (1322/1322), done.\n   remote: Total 2783 (delta 1526), reused 2587 (delta 1387)\n   Receiving objects: 100% (2783/2783), 1.23 MiB | 10 KiB/s, done.\n   Resolving deltas: 100% (1526/1526), completed with 387 local objects.\n   From github.com:schacon/hw\n      8e29b09..c7c5a10  master     -> github/master\n      0709fdc..d4ccf73  c-langs    -> github/c-langs\n      6684f82..ae06d2b  java       -> github/java\n   * [new branch]      ada        -> github/ada\n   * [new branch]      lisp       -> github/lisp","signature":"git fetch remote","description":"download new branches and data from a remote repository. <tt>git fetch</tt> will <tt>synchronize</tt> you with another repo, <tt>pulling down</tt> any data that you do not have locally and giving you <tt>bookmarks</tt> to where each branch on that remote was when you synchronized. These are called \"remote branches\" and are identical to local branches except that Git will <tt>not allow</tt> you to <tt>check them out</tt> - however, you can <tt>merge</tt> from them, <tt>diff</tt> them to other branches, run <tt>history logs</tt> on them, etc. You do all of that stuff locally after you synchronize."},
         {"name":"pull","code":"git pull github","signature":"git pull remote","description":"<tt>fetch</tt> from a <b>remote</b> repo and try to <tt>merge</tt> into the current branch. This command will basically run a <tt>git fetch</tt> immediately followed by a <tt>git merge</tt> of the branch on that remote that is tracked by whatever branch you are currently in."}
      ]
   },
   {
      "name" : "SSH",
      "functions": [
         {"name":"ssh-keygen","code":"ssh-keygen -t rsa -C \"your_email@example.com\"\n=> Generating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/you/.ssh/id_rsa):\n=> [Press enter]\nEnter passphrase (empty for no passphrase):\n=> [Type a passphrase]\nEnter same passphrase again:\n=> [Type passphrase again]\n\n# Your identification has been saved in /c/Users/you/.ssh/id_rsa.\n# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\n# The key fingerprint is:\n# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com","signature":"ssh-keygen -t rsa -C email_address","description":"Creates a new ssh key, using the provided <b>email_address</b> as a label"},
         {"name":"ssh-add","code":"ls -al ~/.ssh\n=> Lists the files in your .ssh directory, if they exist\nssh-add ~/.ssh/id_rsa\n=> add your new key to the ssh-agent","signature":"ssh-add private_key_file","description":"We strongly recommend using an <tt>SSH connection</tt> when interacting with GitHub. <tt>SSH keys</tt> are a way to identify trusted computers, <tt>without involving passwords</tt>."},
         {"name":"ssh-agent","code":"eval \"$(ssh-agent -s)\"\n=> Agent pid 59566\nclip < ~/.ssh/id_rsa.pub\n=> Copies the contents of the id_rsa.pub file to your clipboard\n\n[add key into GitHub]\n\nssh -T git@github.com\n=> attempts to ssh to github\n\ngit remote origin git@github.com:admin/example.git\n=> add remote ssh\ngit pull\n=> pull resources from remote ssh","signature":"eval \"$(ssh-agent -s)\"","description":"start the <tt>ssh-agent</tt> in the background"},
      ]
   },
   {
      "name" : "Submodule",
      "functions": [
         {"name":"submodule","code":"git submodule\n=> c45211f566033e79e22fd587bbaea4bd4ee63e2e submodule_one (remotes/origin/HEAD)\n   11071c385999ee6288b067518e205cd5581be0e7 submodule_two (heads/master)","signature":"git submodule","description":"Show all list <tt>submodule</tt> in project. Return empty if project has zezo subproject"},
         {"name":"add","code":"git submodule add git@github.com:schacon/hw.git\n=> Cloning into 'hw'...\n   remote: Counting objects: 31, done.\n   remote: Compressing objects: 100% (22/22), done.\n   remote: Total 31 (delta 7), reused 0 (delta 0)\n   Unpacking objects: 100% (31/31), done.\n   Checking connectivity... done.","signature":"git submodule add <repository>","description":"Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the \"superproject\"."},
         {"name":"update","code":"git submodule update\n=> Cloning into 'submodule_one'...\n   remote: Counting objects: 52, done.\n   remote: Compressing objects: 100% (47/47), done.\n   remote: Total 52 (delta 14), reused 0 (delta 0)\n   Unpacking objects: 100% (52/52), done.\n   Checking connectivity... done.\n   Submodule path 'asubmodule_one': \n        checked out  '5207758f0f0e5927e2e4acf41eef29da1fbc3b3f'","signature":"git submodule update","description":"Update the registered submodules, i.e. clone missing submodules and checkout the commit specified in the index of the containing repository."},
         {"name":"foreach","code":"git submodule foreach git pull origin master\n=> Entering 'acunetix-scanner'\n   From http://github.com/admin/submodule_one * \n       branch            master     -> FETCH_HEAD\n   Updating 5207758..c45211f\n   Fast-forward\n        readme.txt | 1 +\n        test_file.txt    | 1 +\n    2 files changed, 2 insertions(+)\n    create mode 100644 readme2.txt\n    create mode 100644 test.txt\n    Already up-to-date.","signature":"git submodule foreach <command>","description":"Evaluates an arbitrary shell <b>command</b> in each checked out submodule. The command has access to the variables <tt>$name</tt>, <tt>$path</tt>, <tt>$sha1</tt> and <tt>$toplevel</tt>: <tt>$name</tt> is the name of the relevant submodule section in .gitmodules, <tt>$path</tt> is the name of the submodule directory relative to the superproject, <tt>$sha1</tt> is the commit as recorded in the superproject, and <tt>$toplevel</tt> is the absolute path to the top-level of the superproject."},
         
      ]
   },
   {
      "name" : "NExt",
      "functions": [

      ]
   },
];
